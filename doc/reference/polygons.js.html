<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>polygons.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Animation.html">Animation</a><ul class='methods'><li data-type='method'><a href="Animation.html#done">done</a></li></ul></li><li></li><li><a href="BinaryHeap.html">BinaryHeap</a></li><li></li><li></li><li></li><li><a href="NonlinTransforms.html">NonlinTransforms</a><ul class='methods'><li data-type='method'><a href="NonlinTransforms.html#bendCantilever">bendCantilever</a></li><li data-type='method'><a href="NonlinTransforms.html#bulge">bulge</a></li><li data-type='method'><a href="NonlinTransforms.html#cantilever">cantilever</a></li><li data-type='method'><a href="NonlinTransforms.html#lookAt">lookAt</a></li><li data-type='method'><a href="NonlinTransforms.html#matrix3d">matrix3d</a></li><li data-type='method'><a href="NonlinTransforms.html#parametrize">parametrize</a></li><li data-type='method'><a href="NonlinTransforms.html#perspective">perspective</a></li><li data-type='method'><a href="NonlinTransforms.html#radialRipple">radialRipple</a></li><li data-type='method'><a href="NonlinTransforms.html#rotate3d">rotate3d</a></li><li data-type='method'><a href="NonlinTransforms.html#rotateX">rotateX</a></li><li data-type='method'><a href="NonlinTransforms.html#rotateY">rotateY</a></li><li data-type='method'><a href="NonlinTransforms.html#rotateZ">rotateZ</a></li><li data-type='method'><a href="NonlinTransforms.html#scale3d">scale3d</a></li><li data-type='method'><a href="NonlinTransforms.html#sineWave">sineWave</a></li><li data-type='method'><a href="NonlinTransforms.html#springBend">springBend</a></li><li data-type='method'><a href="NonlinTransforms.html#translate3d">translate3d</a></li><li data-type='method'><a href="NonlinTransforms.html#twistPinch">twistPinch</a></li><li data-type='method'><a href="NonlinTransforms.html#use">use</a></li></ul></li><li></li><li><a href="Set.html">Set</a><ul class='methods'><li data-type='method'><a href="Set.html#.animate">animate</a></li><li data-type='method'><a href="Set.html#.attr">attr</a></li><li data-type='method'><a href="Set.html#.bind">bind</a></li><li data-type='method'><a href="Set.html#.clear">clear</a></li><li data-type='method'><a href="Set.html#.clone">clone</a></li><li data-type='method'><a href="Set.html#.exclude">exclude</a></li><li data-type='method'><a href="Set.html#.filter">filter</a></li><li data-type='method'><a href="Set.html#.forEach">forEach</a></li><li data-type='method'><a href="Set.html#.getBBox">getBBox</a></li><li data-type='method'><a href="Set.html#.includes">includes</a></li><li data-type='method'><a href="Set.html#.insertAfter">insertAfter</a></li><li data-type='method'><a href="Set.html#.map">map</a></li><li data-type='method'><a href="Set.html#.pop">pop</a></li><li data-type='method'><a href="Set.html#.push">push</a></li><li data-type='method'><a href="Set.html#.remove">remove</a></li><li data-type='method'><a href="Set.html#.splice">splice</a></li><li data-type='method'><a href="Set.html#.toString">toString</a></li><li data-type='method'><a href="Set.html#.values">values</a></li></ul></li><li></li><li><a href="Snap.Element.html">Element</a><ul class='methods'><li data-type='method'><a href="Snap.Element.html#.regionSelect">regionSelect</a></li><li data-type='method'><a href="Snap.Element.html#addClickEvent">addClickEvent</a></li><li data-type='method'><a href="Snap.Element.html#addHoldEvent">addHoldEvent</a></li><li data-type='method'><a href="Snap.Element.html#addInteractionEvent">addInteractionEvent</a></li><li data-type='method'><a href="Snap.Element.html#addLongpressEvent">addLongpressEvent</a></li><li data-type='method'><a href="Snap.Element.html#addMessage">addMessage</a></li><li data-type='method'><a href="Snap.Element.html#addPressEvent">addPressEvent</a></li><li data-type='method'><a href="Snap.Element.html#addTransform">addTransform</a></li><li data-type='method'><a href="Snap.Element.html#anchorEmbed">anchorEmbed</a></li><li data-type='method'><a href="Snap.Element.html#animateTransform">animateTransform</a></li><li data-type='method'><a href="Snap.Element.html#attrs">attrs</a></li><li data-type='method'><a href="Snap.Element.html#centerOfMass">centerOfMass</a></li><li data-type='method'><a href="Snap.Element.html#centerRotation">centerRotation</a></li><li data-type='method'><a href="Snap.Element.html#children">children</a></li><li data-type='method'><a href="Snap.Element.html#closest">closest</a></li><li data-type='method'><a href="Snap.Element.html#correctScale">correctScale</a></li><li data-type='method'><a href="Snap.Element.html#createClipPath">createClipPath</a></li><li data-type='method'><a href="Snap.Element.html#createMask">createMask</a></li><li data-type='method'><a href="Snap.Element.html#ellipseTransform">ellipseTransform</a></li><li data-type='method'><a href="Snap.Element.html#fitInBox">fitInBox</a></li><li data-type='method'><a href="Snap.Element.html#flatten">flatten</a></li><li data-type='method'><a href="Snap.Element.html#getAttributes">getAttributes</a></li><li data-type='method'><a href="Snap.Element.html#getBBoxRot">getBBoxRot</a></li><li data-type='method'><a href="Snap.Element.html#getBitmap">getBitmap</a></li><li data-type='method'><a href="Snap.Element.html#getCanvasOverly">getCanvasOverly</a></li><li data-type='method'><a href="Snap.Element.html#getClientHeight">getClientHeight</a></li><li data-type='method'><a href="Snap.Element.html#getClientWidth">getClientWidth</a></li><li data-type='method'><a href="Snap.Element.html#getCoordMatrix">getCoordMatrix</a></li><li data-type='method'><a href="Snap.Element.html#getCursorPoint">getCursorPoint</a></li><li data-type='method'><a href="Snap.Element.html#getDirectionLine">getDirectionLine</a></li><li data-type='method'><a href="Snap.Element.html#getFirstPoint">getFirstPoint</a></li><li data-type='method'><a href="Snap.Element.html#getFromScreenDistance">getFromScreenDistance</a></li><li data-type='method'><a href="Snap.Element.html#getGeometryAttr">getGeometryAttr</a></li><li data-type='method'><a href="Snap.Element.html#getId">getId</a></li><li data-type='method'><a href="Snap.Element.html#getLastPoint">getLastPoint</a></li><li data-type='method'><a href="Snap.Element.html#getRealBBox">getRealBBox</a></li><li data-type='method'><a href="Snap.Element.html#getRealBBoxExact">getRealBBoxExact</a></li><li data-type='method'><a href="Snap.Element.html#getReferringToMe">getReferringToMe</a></li><li data-type='method'><a href="Snap.Element.html#getTopSVG">getTopSVG</a></li><li data-type='method'><a href="Snap.Element.html#globalToLocal">globalToLocal</a></li><li data-type='method'><a href="Snap.Element.html#hide">hide</a></li><li data-type='method'><a href="Snap.Element.html#hideSlowly">hideSlowly</a></li><li data-type='method'><a href="Snap.Element.html#isAbove">isAbove</a></li><li data-type='method'><a href="Snap.Element.html#isBelow">isBelow</a></li><li data-type='method'><a href="Snap.Element.html#isChildOf">isChildOf</a></li><li data-type='method'><a href="Snap.Element.html#isInRect">isInRect</a></li><li data-type='method'><a href="Snap.Element.html#isLocal">isLocal</a></li><li data-type='method'><a href="Snap.Element.html#isOverlap">isOverlap</a></li><li data-type='method'><a href="Snap.Element.html#isOverlapRect">isOverlapRect</a></li><li data-type='method'><a href="Snap.Element.html#isParentOf">isParentOf</a></li><li data-type='method'><a href="Snap.Element.html#linkedElementLocalise">linkedElementLocalise</a></li><li data-type='method'><a href="Snap.Element.html#localOnly">localOnly</a></li><li data-type='method'><a href="Snap.Element.html#makeDraggable">makeDraggable</a></li><li data-type='method'><a href="Snap.Element.html#makePath">makePath</a></li><li data-type='method'><a href="Snap.Element.html#move">move</a></li><li data-type='method'><a href="Snap.Element.html#pathFirstPoint">pathFirstPoint</a></li><li data-type='method'><a href="Snap.Element.html#propagateTransform">propagateTransform</a></li><li data-type='method'><a href="Snap.Element.html#rasterize">rasterize</a></li><li data-type='method'><a href="Snap.Element.html#readChanges">readChanges</a></li><li data-type='method'><a href="Snap.Element.html#recordChange">recordChange</a></li><li data-type='method'><a href="Snap.Element.html#reflect">reflect</a></li><li data-type='method'><a href="Snap.Element.html#remove">remove</a></li><li data-type='method'><a href="Snap.Element.html#removeMessage">removeMessage</a></li><li data-type='method'><a href="Snap.Element.html#removeSlowly">removeSlowly</a></li><li data-type='method'><a href="Snap.Element.html#repositionInGroup">repositionInGroup</a></li><li data-type='method'><a href="Snap.Element.html#revolve">revolve</a></li><li data-type='method'><a href="Snap.Element.html#rotate">rotate</a></li><li data-type='method'><a href="Snap.Element.html#scale">scale</a></li><li data-type='method'><a href="Snap.Element.html#selectParent">selectParent</a></li><li data-type='method'><a href="Snap.Element.html#setCursor">setCursor</a></li><li data-type='method'><a href="Snap.Element.html#setFirstPoint">setFirstPoint</a></li><li data-type='method'><a href="Snap.Element.html#setIdFollowRefs">setIdFollowRefs</a></li><li data-type='method'><a href="Snap.Element.html#show">show</a></li><li data-type='method'><a href="Snap.Element.html#showSlowly">showSlowly</a></li><li data-type='method'><a href="Snap.Element.html#toJSON">toJSON</a></li><li data-type='method'><a href="Snap.Element.html#toPolyBezier">toPolyBezier</a></li><li data-type='method'><a href="Snap.Element.html#translate">translate</a></li><li data-type='method'><a href="Snap.Element.html#translate_glob">translate_glob</a></li><li data-type='method'><a href="Snap.Element.html#translateAnimate">translateAnimate</a></li><li data-type='method'><a href="Snap.Element.html#transparentToMouse">transparentToMouse</a></li><li data-type='method'><a href="Snap.Element.html#a">a</a></li><li data-type='method'><a href="Snap.Element.html#addStop">addStop</a></li><li data-type='method'><a href="Snap.Element.html#arcFan">arcFan</a></li><li data-type='method'><a href="Snap.Element.html#borderImage">borderImage</a></li><li data-type='method'><a href="Snap.Element.html#button">button</a></li><li data-type='method'><a href="Snap.Element.html#canvas">canvas</a></li><li data-type='method'><a href="Snap.Element.html#circle">circle</a></li><li data-type='method'><a href="Snap.Element.html#circleCentPoint">circleCentPoint</a></li><li data-type='method'><a href="Snap.Element.html#circleThreePoints">circleThreePoints</a></li><li data-type='method'><a href="Snap.Element.html#circleTwoPoints">circleTwoPoints</a></li><li data-type='method'><a href="Snap.Element.html#clipPath">clipPath</a></li><li data-type='method'><a href="Snap.Element.html#disk">disk</a></li><li data-type='method'><a href="Snap.Element.html#diskSegments">diskSegments</a></li><li data-type='method'><a href="Snap.Element.html#ellipseFromEquation">ellipseFromEquation</a></li><li data-type='method'><a href="Snap.Element.html#embeddedSVG">embeddedSVG</a></li><li data-type='method'><a href="Snap.Element.html#foreignObject">foreignObject</a></li><li data-type='method'><a href="Snap.Element.html#grid">grid</a></li><li data-type='method'><a href="Snap.Element.html#htmlInsert">htmlInsert</a></li><li data-type='method'><a href="Snap.Element.html#multilineText">multilineText</a></li><li data-type='method'><a href="Snap.Element.html#setStops">setStops</a></li><li data-type='method'><a href="Snap.Element.html#stops">stops</a></li><li data-type='method'><a href="Snap.Element.html#zigzag">zigzag</a></li></ul></li><li><a href="Snap.Fragment.html">Fragment</a></li><li><a href="Snap.html#.Matrix">Matrix</a><ul class='methods'><li data-type='method'><a href="Snap.html#.Matrix#.combine">combine</a></li><li data-type='method'><a href="Snap.html#.Matrix#.random">random</a></li><li data-type='method'><a href="Snap.html#.Matrix#add">add</a></li><li data-type='method'><a href="Snap.html#.Matrix#apply">apply</a></li><li data-type='method'><a href="Snap.html#.Matrix#clone">clone</a></li><li data-type='method'><a href="Snap.html#.Matrix#determinant">determinant</a></li><li data-type='method'><a href="Snap.html#.Matrix#equals">equals</a></li><li data-type='method'><a href="Snap.html#.Matrix#get">get</a></li><li data-type='method'><a href="Snap.html#.Matrix#invert">invert</a></li><li data-type='method'><a href="Snap.html#.Matrix#isIdentity">isIdentity</a></li><li data-type='method'><a href="Snap.html#.Matrix#isMatrix">isMatrix</a></li><li data-type='method'><a href="Snap.html#.Matrix#lusolve">lusolve</a></li><li data-type='method'><a href="Snap.html#.Matrix#multLeft">multLeft</a></li><li data-type='method'><a href="Snap.html#.Matrix#multRight">multRight</a></li><li data-type='method'><a href="Snap.html#.Matrix#offset">offset</a></li><li data-type='method'><a href="Snap.html#.Matrix#plus">plus</a></li><li data-type='method'><a href="Snap.html#.Matrix#randomTrans">randomTrans</a></li><li data-type='method'><a href="Snap.html#.Matrix#rotate">rotate</a></li><li data-type='method'><a href="Snap.html#.Matrix#rotScaleSplit">rotScaleSplit</a></li><li data-type='method'><a href="Snap.html#.Matrix#scale">scale</a></li><li data-type='method'><a href="Snap.html#.Matrix#scMult">scMult</a></li><li data-type='method'><a href="Snap.html#.Matrix#skew">skew</a></li><li data-type='method'><a href="Snap.html#.Matrix#skewX">skewX</a></li><li data-type='method'><a href="Snap.html#.Matrix#skewY">skewY</a></li><li data-type='method'><a href="Snap.html#.Matrix#split">split</a></li><li data-type='method'><a href="Snap.html#.Matrix#split2">split2</a></li><li data-type='method'><a href="Snap.html#.Matrix#timesSc">timesSc</a></li><li data-type='method'><a href="Snap.html#.Matrix#toArray">toArray</a></li><li data-type='method'><a href="Snap.html#.Matrix#toString">toString</a></li><li data-type='method'><a href="Snap.html#.Matrix#toTransformString">toTransformString</a></li><li data-type='method'><a href="Snap.html#.Matrix#translate">translate</a></li><li data-type='method'><a href="Snap.html#.Matrix#twoPointTransform">twoPointTransform</a></li><li data-type='method'><a href="Snap.html#.Matrix#twoPointTransformMatrix">twoPointTransformMatrix</a></li><li data-type='method'><a href="Snap.html#.Matrix#x">x</a></li><li data-type='method'><a href="Snap.html#.Matrix#y">y</a></li></ul></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li><a href="Snap.Paper.html">Paper</a><ul class='methods'><li data-type='method'><a href="Snap.Paper.html#addExtension">addExtension</a></li><li data-type='method'><a href="Snap.Paper.html#animate">animate</a></li><li data-type='method'><a href="Snap.Paper.html#animateMotion">animateMotion</a></li><li data-type='method'><a href="Snap.Paper.html#circle">circle</a></li><li data-type='method'><a href="Snap.Paper.html#clear">clear</a></li><li data-type='method'><a href="Snap.Paper.html#ellipse">ellipse</a></li><li data-type='method'><a href="Snap.Paper.html#g">g</a></li><li data-type='method'><a href="Snap.Paper.html#gradient">gradient</a></li><li data-type='method'><a href="Snap.Paper.html#gradientLinear">gradientLinear</a></li><li data-type='method'><a href="Snap.Paper.html#gradientRadial">gradientRadial</a></li><li data-type='method'><a href="Snap.Paper.html#image">image</a></li><li data-type='method'><a href="Snap.Paper.html#line">line</a></li><li data-type='method'><a href="Snap.Paper.html#mask">mask</a></li><li data-type='method'><a href="Snap.Paper.html#measureText">measureText</a></li><li data-type='method'><a href="Snap.Paper.html#mpath">mpath</a></li><li data-type='method'><a href="Snap.Paper.html#path">path</a></li><li data-type='method'><a href="Snap.Paper.html#point">point</a></li><li data-type='method'><a href="Snap.Paper.html#polygon">polygon</a></li><li data-type='method'><a href="Snap.Paper.html#polyline">polyline</a></li><li data-type='method'><a href="Snap.Paper.html#processExtensions">processExtensions</a></li><li data-type='method'><a href="Snap.Paper.html#ptrn">ptrn</a></li><li data-type='method'><a href="Snap.Paper.html#rect">rect</a></li><li data-type='method'><a href="Snap.Paper.html#svg">svg</a></li><li data-type='method'><a href="Snap.Paper.html#symbol">symbol</a></li><li data-type='method'><a href="Snap.Paper.html#text">text</a></li><li data-type='method'><a href="Snap.Paper.html#textInputBox">textInputBox</a></li><li data-type='method'><a href="Snap.Paper.html#textPath">textPath</a></li><li data-type='method'><a href="Snap.Paper.html#toDataURL">toDataURL</a></li><li data-type='method'><a href="Snap.Paper.html#toString">toString</a></li><li data-type='method'><a href="Snap.Paper.html#use">use</a></li></ul></li><li></li><li></li><li></li><li><a href="Snap.Set.html">Set</a></li><li></li></ul><h3>Events</h3><ul><li><a href="snap.util.html#.event:equal">equal</a></li><li></li></ul><h3>Namespaces</h3><ul><li><a href="Matrix.gen.html">gen</a></li><li></li><li><a href="Snap.polygons.html">polygons</a><ul class='methods'><li data-type='method'><a href="Snap.polygons.html#.findPointInsidePolygon">findPointInsidePolygon</a></li><li data-type='method'><a href="Snap.polygons.html#.intersect">intersect</a></li><li data-type='method'><a href="Snap.polygons.html#.polygonArea">polygonArea</a></li><li data-type='method'><a href="Snap.polygons.html#.polygonCentroid">polygonCentroid</a></li></ul></li><li><a href="Snap.bbox.html">bbox</a></li><li></li><li></li></ul><h3>Global</h3><ul><li><a href="global.html#Checksifthegiveneventisregisteredwiththegivenfunction.">Checks if the given event is registered with the given function.</a></li><li><a href="global.html#compareInt">compareInt</a></li><li><a href="global.html#getLengthFactory">getLengthFactory</a></li><li><a href="global.html#O">O</a></li><li><a href="global.html#reverse_seg">reverse_seg</a></li><li><a href="global.html#voronoi">voronoi</a></li><li><a href="global.html#voronoi1D">voronoi1D</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">polygons.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Polygon intersection and geometric operations library
 * Based on https://github.com/vrd/js-intersect
 * Provides functions for polygon intersection, point-in-polygon testing, and related geometric calculations.
 * 
 * @typedef {Object} Point
 * @property {Number} x - X coordinate
 * @property {Number} y - Y Coordinate
 * @property {Number} [t] - Parametric position along edge (0-1)
 * @property {Number} [theta] - Polar angle for point classification
 * 
 * @typedef {Array&lt;Point>} Polygon
 * Array of points representing polygon vertices in order
 * 
 * @typedef {Array&lt;Point>} Edge
 * Array of exactly two points representing an edge
 */

//code based on https://github.com/vrd/js-intersect

Snap.plugin(function (Snap, Element, Paper, glob, Fragment, eve) {
    /**
     * Namespace for polygon-related operations
     * @namespace Snap.polygons
     */
    Snap.polygons = Snap.polygons || {}
    
    /**
     * Finds the intersection of two polygons
     * @function intersect
     * @memberof Snap.polygons
     * @param {Array&lt;Point>} fig1 - First polygon as array of points
     * @param {Array&lt;Point>} fig2 - Second polygon as array of points
     * @returns {Array&lt;Array&lt;Point>>|false} Array of intersection polygons or false if no intersection
     * @example
     * const poly1 = [{x: 0, y: 0}, {x: 10, y: 0}, {x: 10, y: 10}, {x: 0, y: 10}];
     * const poly2 = [{x: 5, y: 5}, {x: 15, y: 5}, {x: 15, y: 15}, {x: 5, y: 15}];
     * const intersection = Snap.polygons.intersect(poly1, poly2);
     */
    function intersect(fig1, fig2) {
        let fig2a = alignPolygon(fig2, fig1);
        if (!checkPolygons(fig1, fig2a)) {
            return false;
        }
        const edges = edgify(fig1, fig2a);
        const polygons = polygonate(edges);
        return filterPolygons(polygons, fig1, fig2a, "intersect");
    }

    Snap.polygons.intersect = intersect;

    /**
     * Aligns vertices of one polygon with vertices of another polygon within tolerance
     * @function alignPolygon
     * @private
     * @param {Array&lt;Point>} polygon - Polygon to align
     * @param {Array&lt;Point>} points - Reference points for alignment
     * @returns {Array&lt;Point>} Aligned polygon
     */
    function alignPolygon(polygon, points) {
        for (let i = 0; i &lt; polygon.length; i++) {
            for (let j = 0; j &lt; points.length; j++) {
                if (distance(polygon[i], points[j]) &lt; 0.00000001)
                    polygon[i] = points[j];
            }
        }
        return polygon;
    }

    /**
     * Calculates Euclidean distance between two points
     * @function distance
     * @private
     * @param {Point} p1 - First point
     * @param {Point} p2 - Second point
     * @returns {Number} Distance between the points
     */
    function distance(p1, p2) {
        const dx = Math.abs(p1.x - p2.x);
        const dy = Math.abs(p1.y - p2.y);
        return Math.sqrt(dx*dx + dy*dy);
    }

    /**
     * Validates that polygons have at least 3 vertices
     * @function checkPolygons
     * @private
     * @param {Array&lt;Point>} fig1 - First polygon
     * @param {Array&lt;Point>} fig2 - Second polygon
     * @returns {Boolean} True if both polygons are valid, false otherwise
     */
    //check polygons for correctness
    function checkPolygons(fig1, fig2) {
        const figs = [fig1, fig2];
        for (let i = 0; i &lt; figs.length; i++) {
            if (figs[i].length &lt; 3) {
                console.error("Polygon " + (i+1) + " is invalid!");
                return false;
            }
        }
        return true;
    }

    /**
     * Creates array of all polygon edges with intersection points
     * @function edgify
     * @private
     * @param {Array&lt;Point>} fig1 - First polygon
     * @param {Array&lt;Point>} fig2 - Second polygon
     * @returns {Array&lt;Array&lt;Point>>} Array of edge segments
     */
    //create array of edges of all polygons
    function edgify(fig1, fig2) {
        //create primary array from all edges
        const primEdges = getEdges(fig1).concat(getEdges(fig2));
        const secEdges = [];
        //check every edge
        for(let i = 0; i &lt; primEdges.length; i++) {
            let points = [];
            //for intersection with every edge except itself
            for(let j = 0; j &lt; primEdges.length; j++) {
                if (i !== j) {
                    const interPoints = findEdgeIntersection(primEdges[i], primEdges[j]);
                    addNewPoints(interPoints, points);
                }
            }
            //add start and end points to intersection points
            let startPoint = primEdges[i][0];
            startPoint.t = 0;
            let endPoint = primEdges[i][1];
            endPoint.t = 1;
            addNewPoints([startPoint, endPoint], points);
            //sort all points by position on edge
            points = sortPoints(points);
            //break edge to parts
            for (let k = 0; k &lt; points.length - 1; k++) {
                const edge = [
                    {x: points[k].x, y: points[k].y},
                    {x: points[k + 1].x, y: points[k + 1].y}
                ];
                // check for existanse in sec.array
                if (!edgeExists(edge, secEdges)) {
                    //push if not exists
                    secEdges.push(edge);
                }
            }
        }
        return secEdges;
    }

    /**
     * Adds new unique points to a points array
     * @function addNewPoints
     * @private
     * @param {Array&lt;Point>} newPoints - Points to add
     * @param {Array&lt;Point>} points - Existing points array
     */
    function addNewPoints(newPoints, points) {
        if (newPoints.length > 0) {
            //check for uniqueness
            for (let k = 0; k &lt; newPoints.length; k++) {
                if (!pointExists(newPoints[k], points)) {
                    points.push(newPoints[k]);
                }
            }
        }
    }

    /**
     * Sorts points along an edge by their parametric position (t value)
     * @function sortPoints
     * @private
     * @param {Array&lt;Point>} points - Points with t values to sort
     * @returns {Array&lt;Point>} Sorted points array
     */
    function sortPoints(points) {
        const p = points;
        p.sort((a,b) => {
            if (a.t > b.t) return 1;
            if (a.t &lt; b.t) return -1;
            return 0;
        });
        return p;
    }

    /**
     * Converts polygon vertices to array of edges
     * @function getEdges
     * @private
     * @param {Array&lt;Point>} fig - Polygon vertices
     * @returns {Array&lt;Array&lt;Point>>} Array of edges, each edge is array of two points
     */
    function getEdges(fig) {
        const edges = [];
        const len = fig.length;
        for (let i = 0; i &lt; len; i++) {
            edges.push([
                {x: fig[(i % len)].x, y: fig[(i % len)].y},
                {x: fig[((i+1) % len)].x, y: fig[((i+1) % len)].y}
            ]);
        }
        return edges;
    }

    /**
     * Finds intersection points between two edges
     * @function findEdgeIntersection
     * @private
     * @param {Array&lt;Point>} edge1 - First edge as array of two points
     * @param {Array&lt;Point>} edge2 - Second edge as array of two points
     * @returns {Array&lt;Point>} Array of intersection points with t parameter
     */
    function findEdgeIntersection(edge1, edge2) {
        const x1 = edge1[0].x;
        const x2 = edge1[1].x;
        const x3 = edge2[0].x;
        const x4 = edge2[1].x;
        const y1 = edge1[0].y;
        const y2 = edge1[1].y;
        const y3 = edge2[0].y;
        const y4 = edge2[1].y;
        const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
        const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
        const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
        const t1 = nom1 / denom;
        const t2 = nom2 / denom;
        const interPoints = [];
        //1. lines are parallel or edges don't intersect
        if (((denom === 0) &amp;&amp; (nom1 !== 0)) || (t1 &lt;= 0) || (t1 >= 1) || (t2 &lt; 0 ) || (t2 > 1)) {
            return interPoints;
        }
        //2. lines are collinear
        else if ((nom1 === 0) &amp;&amp; (denom === 0)) {
            //check if endpoints of edge2 lies on edge1
            for (let i = 0; i &lt; 2; i++) {
                const classify = classifyPoint(edge2[i], edge1);
                //find position of this endpoints relatively to edge1
                if (classify.loc === "ORIGIN" || classify.loc === "DESTINATION") {
                    interPoints.push({x: edge2[i].x, y: edge2[i].y, t: classify.t});
                }
                else if (classify.loc === "BETWEEN") {
                    const x = +((x1 + classify.t*(x2 - x1)).toPrecision(10));
                    const y = +((y1 + classify.t*(y2 - y1)).toPrecision(10));
                    interPoints.push({x: x, y: y, t: classify.t});
                }
            }
            return interPoints;
        }
        //3. edges intersect
        else {
            for (let i = 0; i &lt; 2; i++) {
                const classify = classifyPoint(edge2[i], edge1);
                if (classify.loc === "ORIGIN" || classify.loc === "DESTINATION") {
                    interPoints.push({x: edge2[i].x, y: edge2[i].y, t: classify.t});
                }
            }
            if (interPoints.length > 0) {
                return interPoints;
            }
            const x = +((x1 + t1*(x2 - x1)).toPrecision(10));
            const y = +((y1 + t1*(y2 - y1)).toPrecision(10));
            interPoints.push({x: x, y: y, t: t1});
            return interPoints;
        }
    }

    /**
     * Classifies position of a point relative to an edge
     * @function classifyPoint
     * @private
     * @param {Point} p - Point to classify
     * @param {Array&lt;Point>} edge - Edge as array of two points
     * @returns {Object} Classification result with location and theta/t values
     */
    function classifyPoint(p, edge) {
        const ax = edge[1].x - edge[0].x;
        const ay = edge[1].y - edge[0].y;
        const bx = p.x - edge[0].x;
        const by = p.y - edge[0].y;
        const sa = ax * by - bx * ay;
        if ((p.x === edge[0].x) &amp;&amp; (p.y === edge[0].y)) {
            return {loc: "ORIGIN", t: 0};
        }
        if ((p.x === edge[1].x) &amp;&amp; (p.y === edge[1].y)) {
            return {loc: "DESTINATION", t: 1};
        }
        let theta = (polarAngle([edge[1], edge[0]]) -
            polarAngle([{x: edge[1].x, y: edge[1].y}, {x: p.x, y: p.y}])) % 360;
        if (theta &lt; 0) {
            theta = theta + 360;
        }
        if (sa &lt; -0.0000000001) {
            return {loc: "LEFT", theta: theta};
        }
        if (sa > 0.00000000001) {
            return {loc: "RIGHT", theta: theta};
        }
        if (((ax * bx) &lt; 0) || ((ay * by) &lt; 0)) {
            return {loc: "BEHIND", theta: 0};
        }
        if ((Math.sqrt(ax * ax + ay * ay)) &lt; (Math.sqrt(bx * bx + by * by))) {
            return {loc: "BEYOND", theta: 180};
        }
        let t;
        if (ax !== 0) {
            t = bx/ax;
        } else {
            t = by/ay;
        }
        return {loc: "BETWEEN", t: t};
    }

    /**
     * Calculates polar angle of an edge in degrees
     * @function polarAngle
     * @private
     * @param {Array&lt;Point>} edge - Edge as array of two points
     * @returns {Number|Boolean} Angle in degrees or false if zero-length edge
     */
    function polarAngle(edge) {
        const dx = edge[1].x - edge[0].x;
        const dy = edge[1].y - edge[0].y;
        if ((dx === 0) &amp;&amp; (dy === 0)) {
            //console.error("Edge has zero length.");
            return false;
        }
        if (dx === 0) {
            return ((dy > 0) ? 90 : 270);
        }
        if (dy === 0) {
            return ((dx > 0) ? 0 : 180);
        }
        const theta = Math.atan(dy / dx) * 360 / (2 * Math.PI);
        if (dx > 0) {
            return ((dy >= 0) ? theta : theta + 360);
        } else {
            return (theta + 180);
        }
    }

    /**
     * Checks if a point exists in an array of points
     * @function pointExists
     * @private
     * @param {Point} p - Point to check
     * @param {Array&lt;Point>} points - Array of points to search
     * @returns {Boolean} True if point exists, false otherwise
     */
    function pointExists(p, points) {
        if (points.length === 0) {
            return false;
        }
        for (let i = 0; i &lt; points.length; i++) {
            if ((p.x === points[i].x) &amp;&amp; (p.y === points[i].y)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Checks if an edge exists in an array of edges
     * @function edgeExists
     * @private
     * @param {Array&lt;Point>} e - Edge to check
     * @param {Array&lt;Array&lt;Point>>} edges - Array of edges to search
     * @returns {Boolean} True if edge exists, false otherwise
     */
    function edgeExists(e, edges) {
        if (edges.length === 0) {
            return false;
        }
        for (let i = 0; i &lt; edges.length; i++) {
            if (equalEdges(e, edges[i]))
                return true;
        }
        return false;
    }

    /**
     * Compares two edges for equality (considering both directions)
     * @function equalEdges
     * @private
     * @param {Array&lt;Point>} edge1 - First edge
     * @param {Array&lt;Point>} edge2 - Second edge
     * @returns {Boolean} True if edges are equal, false otherwise
     */
    function equalEdges(edge1, edge2) {
        return ((edge1[0].x === edge2[0].x) &amp;&amp;
            (edge1[0].y === edge2[0].y) &amp;&amp;
            (edge1[1].x === edge2[1].x) &amp;&amp;
            (edge1[1].y === edge2[1].y)) || (
            (edge1[0].x === edge2[1].x) &amp;&amp;
            (edge1[0].y === edge2[1].y) &amp;&amp;
            (edge1[1].x === edge2[0].x) &amp;&amp;
            (edge1[1].y === edge2[0].y));
    }

    /**
     * Creates polygons from an array of edges using edge-following algorithm
     * @function polygonate
     * @private
     * @param {Array&lt;Array&lt;Point>>} edges - Array of edges
     * @returns {Array&lt;Array&lt;Point>>} Array of polygons found
     */
    function polygonate(edges) {
        const polygons = [];
        let polygon = [];
        const len = edges.length;
        const midpoints = getMidpoints(edges);
        //start from every edge and create non-selfintersecting polygons
        for (let i = 0; i &lt; len - 2; i++) {
            const org = {x: edges[i][0].x, y: edges[i][0].y};
            const dest = {x: edges[i][1].x, y: edges[i][1].y};
            let currentEdge = i;
            let point;
            let p;
            let direction;
            let stop;
            //while we havn't come to the starting edge again
            for (direction = 0; direction &lt; 2; direction++) {
                polygon = [];
                stop = false;
                while ((polygon.length === 0) || (!stop)) {
                    //add point to polygon
                    polygon.push({x: org.x, y: org.y});
                    point = undefined;
                    //look for edge connected with end of current edge
                    for (let j = 0; j &lt; len; j++) {
                        p = undefined;
                        //except itself
                        if (!equalEdges(edges[j], edges[currentEdge])) {
                            //if some edge is connected to current edge in one endpoint
                            if ((edges[j][0].x === dest.x) &amp;&amp; (edges[j][0].y === dest.y)) {
                                p = edges[j][1];
                            }
                            if ((edges[j][1].x === dest.x) &amp;&amp; (edges[j][1].y === dest.y)) {
                                p = edges[j][0];
                            }
                            //compare it with last found connected edge for minimum angle between itself and current edge
                            if (p) {
                                const classify = classifyPoint(p, [org, dest]);
                                //if this edge has smaller theta then last found edge update data of next edge of polygon
                                if (!point ||
                                    ((classify.theta &lt; point.theta) &amp;&amp; (direction === 0)) ||
                                    ((classify.theta > point.theta) &amp;&amp; (direction === 1))) {
                                    point = {x: p.x, y: p.y, theta: classify.theta, edge: j};
                                }
                            }
                        }
                    }
                    //change current edge to next edge
                    org.x = dest.x;
                    org.y = dest.y;
                    dest.x = point.x;
                    dest.y = point.y;
                    currentEdge = point.edge;
                    //if we reach start edge
                    if ((org.x === edges[i][0].x) &amp;&amp;
                        (org.y === edges[i][0].y) &amp;&amp;
                        (dest.x === edges[i][1].x) &amp;&amp;
                        (dest.y === edges[i][1].y)) {
                        stop = true;
                        //check polygon for correctness
                        /*for (var k = 0; k &lt; allPoints.length; k++) {
                          //if some point is inside polygon it is incorrect
                          if ((!pointExists(allPoints[k], polygon)) &amp;&amp; (findPointInsidePolygon(allPoints[k], polygon))) {
                            polygon = false;
                          }
                        }*/
                        for (let k = 0; k &lt; midpoints.length; k++) {
                            //if some midpoint is inside polygon (edge inside polygon) it is incorrect
                            if (findPointInsidePolygon(midpoints[k], polygon)) {
                                polygon = false;
                            }
                        }
                    }
                }
                //add created polygon if it is correct and was not found before
                if (polygon &amp;&amp; !polygonExists(polygon, polygons)) {
                    polygons.push(polygon);
                }
            }
        }
        //console.log("polygonate: " + JSON.stringify(polygons));
        return polygons;
    }

    /**
     * Checks if a polygon already exists in an array of polygons
     * @function polygonExists
     * @private
     * @param {Array&lt;Point>} polygon - Polygon to check
     * @param {Array&lt;Array&lt;Point>>} polygons - Array of polygons to search
     * @returns {Boolean} True if polygon exists, false otherwise
     */
    function polygonExists(polygon, polygons) {
        //if array is empty element doesn't exist in it
        if (polygons.length === 0) return false;
        //check every polygon in array
        for (let i = 0; i &lt; polygons.length; i++) {
            //if lengths are not same go to next element
            if (polygon.length !== polygons[i].length) continue;
            //if length are same need to check
            else {
                //if all the points are same
                for (let j = 0; j &lt; polygon.length; j++) {
                    //if point is not found break forloop and go to next element
                    if (!pointExists(polygon[j], polygons[i])) break;
                    //if point found
                    else {
                        //and it is last point in polygon we found polygon in array!
                        if (j === polygon.length - 1) return true;
                    }
                }
            }
        }
        return false;
    }

    /**
     * Filters polygons based on intersection mode and position relative to input polygons
     * @function filterPolygons
     * @private
     * @param {Array&lt;Array&lt;Point>>} polygons - Array of polygons to filter
     * @param {Array&lt;Point>} fig1 - First input polygon
     * @param {Array&lt;Point>} fig2 - Second input polygon
     * @param {String} mode - Filter mode: "intersect", "cut1", "cut2", or "sum"
     * @returns {Array&lt;Array&lt;Point>>} Filtered polygons array
     */
    function filterPolygons(polygons, fig1, fig2, mode) {
        const filtered = [];
        let c1, c2;
        let point;
        const bigPolygons = removeSmallPolygons(polygons, 0.0001);
        for(let i = 0; i &lt; bigPolygons.length; i++) {
            point = getPointInsidePolygon(bigPolygons[i]);
            c1 = findPointInsidePolygon(point, fig1);
            c2 = findPointInsidePolygon(point, fig2);
            if (
                ((mode === "intersect") &amp;&amp; c1 &amp;&amp; c2) || //intersection
                ((mode === "cut1") &amp;&amp; c1 &amp;&amp; !c2) ||     //fig1 - fig2
                ((mode === "cut2") &amp;&amp; !c1 &amp;&amp; c2) ||     //fig2 - fig2
                ((mode === "sum") &amp;&amp; (c1 || c2))) {     //fig1 + fig2
                filtered.push(bigPolygons[i]);
            }
        }
        //console.log("filtered: " + JSON.stringify(filtered));
        return filtered;
    }

    /**
     * Removes polygons smaller than minimum area threshold
     * @function removeSmallPolygons
     * @private
     * @param {Array&lt;Array&lt;Point>>} polygons - Array of polygons
     * @param {Number} minSize - Minimum area threshold
     * @returns {Array&lt;Array&lt;Point>>} Array of polygons above threshold
     */
    function removeSmallPolygons(polygons, minSize) {
        const big = [];
        for (let i = 0; i &lt; polygons.length; i++) {
            if (polygonArea(polygons[i]) >= minSize) {
                big.push(polygons[i]);
            }
        }
        return big;
    }

    /**
     * Calculates the area of a polygon using the shoelace formula
     * @function polygonArea
     * @memberof Snap.polygons
     * @param {Array&lt;Point>} points - Polygon vertices
     * @returns {Number} Area of the polygon
     * @example
     * const square = [{x: 0, y: 0}, {x: 10, y: 0}, {x: 10, y: 10}, {x: 0, y: 10}];
     * const area = Snap.polygons.polygonArea(square); // Returns 100
     */
    function polygonArea(points) {
        const len = points.length;
        let s = 0;
        for (let i = 0; i &lt; len; i++) {
            s += Math.abs((points[i % len].x * points[(i + 1) % len].y) - (points[i % len].y *
                points[(i + 1) % len].x));
        }
        return s/2;
    }

    Snap.polygons.polygonArea = polygonArea;

    /**
     * Finds a point guaranteed to be inside a polygon
     * @function getPointInsidePolygon
     * @private
     * @param {Array&lt;Point>} polygon - Polygon vertices
     * @returns {Point|undefined} Point inside polygon or undefined if none found
     */
    function getPointInsidePolygon(polygon) {
        let point;
        const size = getSize(polygon);
        const edges = getEdges(polygon);
        let y = size.y.min + (size.y.max - size.y.min) / Math.PI;
        const dy = (size.y.max - size.y.min) / 13;
        let line = [];
        let points;
        let interPoints = [];
        let pointsOK = false;
        while (!pointsOK) {
            line = [{x: (size.x.min - 1), y: y},{x: (size.x.max + 1), y: y}];
            //find intersections with all polygon edges
            for (let i = 0; i &lt; edges.length; i++) {
                points = findEdgeIntersection(line, edges[i]);
                //if edge doesn't lie inside line
                if (points &amp;&amp; (points.length === 1)) {
                    interPoints.push(points[0]);
                }
            }
            interPoints = sortPoints(interPoints);
            //find two correct interpoints
            for (let i = 0; i &lt; interPoints.length - 1; i++) {
                if (interPoints[i].t !== interPoints[i+1].t) {
                    //enable exit from loop and calculate point coordinates
                    pointsOK = true;
                    point = {x: ((interPoints[i].x + interPoints[i+1].x) / 2), y: y};
                }
            }
            //all points are incorrect, need to change line parameters
            y = y + dy;
            if (((y > size.y.max) || (y &lt; size.y.min)) &amp;&amp; (pointsOK === false)) {
                pointsOK = true;
                point = undefined;
            }
        }
        return point;
    }

    /**
     * Gets the bounding box dimensions of a polygon
     * @function getSize
     * @private
     * @param {Array&lt;Point>} polygon - Polygon vertices
     * @returns {Object} Object with min/max x and y coordinates
     */
    function getSize(polygon) {
        const size = {
            x: {
                min: polygon[0].x,
                max: polygon[0].x
            },
            y: {
                min: polygon[0].y,
                max: polygon[0].y
            }
        };
        for (let i = 1; i &lt; polygon.length; i++) {
            if (polygon[i].x &lt; size.x.min) size.x.min = polygon[i].x;
            if (polygon[i].x > size.x.max) size.x.max = polygon[i].x;
            if (polygon[i].y &lt; size.y.min) size.y.min = polygon[i].y;
            if (polygon[i].y > size.y.max) size.y.max = polygon[i].y;
        }
        return size;
    }

    /**
     * Tests if a point is inside a polygon using ray casting algorithm
     * @function findPointInsidePolygon
     * @memberof Snap.polygons
     * @param {Point|Array&lt;Number>} point - Point to test (object with x,y or array [x,y])
     * @param {Array&lt;Point>} polygon - Polygon vertices
     * @param {Boolean} [count_side] - Whether to count points on polygon boundary as inside
     * @returns {Boolean} True if point is inside polygon, false otherwise
     * @example
     * const polygon = [{x: 0, y: 0}, {x: 10, y: 0}, {x: 10, y: 10}, {x: 0, y: 10}];
     * const isInside = Snap.polygons.pointInPolygon({x: 5, y: 5}, polygon); // Returns true
     */
    function findPointInsidePolygon(point, polygon, count_side) {
        if (Array.isArray(point)) point = {x:point[0], y:point[1]};

        let cross = 0;
        const edges = getEdges(polygon);
        let classify;
        let org, dest;
        for (let i = 0; i &lt; edges.length; i++) {
            [org, dest] = edges[i];
            classify = classifyPoint(point, [org, dest]);
            if (  (
                    (classify.loc === "RIGHT") &amp;&amp;
                    (org.y &lt; point.y) &amp;&amp;
                    (dest.y >= point.y)
                ) ||
                (
                    (classify.loc === "LEFT") &amp;&amp;
                    (org.y >= point.y) &amp;&amp;
                    (dest.y &lt; point.y)
                )
            ) {
                cross++;
            }
            if (classify.loc === "BETWEEN") return !!count_side;
        }
        return cross % 2 === 1;
    }

    Snap.polygons.pointInPolygon = findPointInsidePolygon;

    /**
     * Calculates midpoints of all edges
     * @function getMidpoints
     * @private
     * @param {Array&lt;Array&lt;Point>>} edges - Array of edges
     * @returns {Array&lt;Point>} Array of midpoints
     */
    function getMidpoints(edges) {
        const midpoints = [];
        let x, y;
        for (let i = 0; i &lt; edges.length; i++) {
            x = (edges[i][0].x + edges[i][1].x) / 2;
            y = (edges[i][0].y + edges[i][1].y) / 2;
            midpoints.push({x: x, y: y});
        }
        return midpoints;
    }

    /**
     * Computes the center of mass (centroid) of a polygon.
     * Assumes uniform distribution of mass.
     * @function polygonCentroid
     * @memberof Snap.polygons
     * @param {Array&lt;Point>} points - Polygon vertices.
     * @returns {Point|null} The center of mass, or null if the polygon has zero area.
     * @example
     * const triangle = [{x: 0, y: 0}, {x: 6, y: 0}, {x: 3, y: 6}];
     * const centroid = Snap.polygons.polygonCentroid(triangle); // Returns {x: 3, y: 2}
     */
    function polygonCentroid(points) {
        let signedArea = 0;
        let cx = 0;
        let cy = 0;
        const len = points.length;

        for (let i = 0; i &lt; len; i++) {
            const p1 = points[i];
            const p2 = points[(i + 1) % len];
            const crossProduct = (p1.x * p2.y) - (p2.x * p1.y);
            signedArea += crossProduct;
            cx += (p1.x + p2.x) * crossProduct;
            cy += (p1.y + p2.y) * crossProduct;
        }

        signedArea /= 2;

        if (Math.abs(signedArea) &lt; 1e-9) {
            return null; // Or handle degenerate polygon as needed
        }

        cx = cx / (6 * signedArea);
        cy = cy / (6 * signedArea);

        return { x: cx, y: cy };
    }

    Snap.polygons.polygonCentroid = polygonCentroid;

});</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a> on Mon Dec 01 2025 11:14:47 GMT-0800 (Pacific Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
